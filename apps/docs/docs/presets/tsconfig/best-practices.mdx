---
id: best-practices
title: Best Practices
description: TSConfig best practices for Nova with small preset chains, explicit wiring, and stable compiler behavior for Node and bundlers.
sidebar_position: 1
keywords:
  - nova
  - tsconfig best practices
  - typescript strict
  - module and moduleResolution
  - baseUrl and paths
  - ambient types
  - isolatedModules
  - noEmit
  - deterministic builds
  - esm modules
  - node runtime
tags:
  - tsconfig
  - best-practices
  - presets
  - reference
---

import { Icon } from '@iconify/react';

# Best Practices

Practical TSConfig guidance for Nova that uses **small, composable preset chains**. Favor **explicit wiring** and **predictable** compiler behavior.

## Dos and Don'ts

<details>
  <summary>
    <Icon icon="openmoji:check-mark" width="20" height="20" />
    <span>DO: Order presets intentionally</span>
  </summary>
  <ul>
    <li><strong>What</strong>: Use a layered <code>{'"extends"'}</code> chain in this order: <em>essentials → strict → environment/framework → platform → tool → your custom overrides</em>.</li>
    <li><strong>Why</strong>: The base loads first; the child overrides it. A clear order keeps policy layered and reviewable.</li>
  </ul>
</details>

<details>
  <summary>
    <Icon icon="openmoji:check-mark" width="20" height="20" />
    <span>DO: Pair <code>{'module'}</code> with <code>{'moduleResolution'}</code> correctly</span>
  </summary>
  <ul>
    <li><strong>What</strong>: Keep them in sync by using <code>{'"module": "nodenext"'}</code> with <code>{'"moduleResolution": "nodenext"'}</code> for Node [ESM](/docs/quickstart/terminology#javascript-and-typescript), or <code>{'"module": "esnext"'}</code> with <code>{'"moduleResolution": "bundler"'}</code> for [bundlers](/docs/quickstart/terminology#builds-and-tooling).</li>
    <li><strong>Why</strong>: Mismatched values make TypeScript and your runtime resolve imports differently, which causes "cannot find module" errors. Pairing keeps resolution consistent.</li>
  </ul>
</details>

<details>
  <summary>
    <Icon icon="openmoji:check-mark" width="20" height="20" />
    <span>DO: Pair <code>{'baseUrl'}</code> with <code>{'paths'}</code></span>
  </summary>
  <ul>
    <li><strong>What</strong>: Set <code>{'baseUrl'}</code> when you define import aliases in <code>{'paths'}</code>.</li>
    <li><strong>Why</strong>: <code>{'paths'}</code> relies on <code>{'baseUrl'}</code>. Editors and builds need both to resolve aliases correctly.</li>
  </ul>
</details>

<details>
  <summary>
    <Icon icon="openmoji:check-mark" width="20" height="20" />
    <span>DO: Path-related settings belong in the app's <code>{'tsconfig.json'}</code></span>
  </summary>
  <ul>
    <li><strong>What</strong>: Path-related settings like <code>{'baseUrl'}</code>, <code>{'paths'}</code>, <code>{'rootDir'}</code>, <code>{'outDir'}</code>, <code>{'include'}</code>, and <code>{'exclude'}</code> belong in the app's <code>{'tsconfig.json'}</code> file, not in Nova presets.</li>
    <li><strong>Why</strong>: TypeScript evaluates these against the file's location. Local wiring avoids resolution mistakes across different repos.</li>
  </ul>
</details>

<details>
  <summary>
    <Icon icon="openmoji:check-mark" width="20" height="20" />
    <span>DO: Declare ambient types explicitly</span>
  </summary>
  <ul>
    <li><strong>What</strong>: Use <code>{'types'}</code> to list the type packages you installed (e.g., <code>{'@types/node'}</code>, <code>{'@types/react'}</code>).</li>
    <li><strong>Why</strong>: Makes type sources explicit and under the app's control. Reduces surprises from transitive <code>{'@types'}</code> dependencies.</li>
  </ul>
</details>

<details>
  <summary>
    <Icon icon="openmoji:check-mark" width="20" height="20" />
    <span>DO: Configure type-checking when a bundler transpiles</span>
  </summary>
  <ul>
    <li><strong>What</strong>: If your project does not use <code>{'tsc'}</code> to build, set <code>{'"isolatedModules": true'}</code> and <code>{'"noEmit": true'}</code> in the app's <code>{'tsconfig.json'}</code>.</li>
    <li><strong>Why</strong>: Bundlers and frameworks compile each file independently. <code>{'isolatedModules'}</code> enforces per-file safety. <code>{'noEmit'}</code> prevents TypeScript from writing JavaScript when another tool already emits output.</li>
  </ul>
</details>

<details>
  <summary>
    <Icon icon="openmoji:cross-mark" width="20" height="20" />
    <span>DON'T: Assume arrays merge/spread like JavaScript</span>
  </summary>
  <ul>
    <li><strong>What</strong>: Do not expect array settings like <code>{'lib'}</code> to spread values from the base.</li>
    <li><strong>Why</strong>: In <code>{'tsconfig'}</code>, these arrays <strong>replace</strong> the parent. This is a config limitation, not JS behavior.</li>
  </ul>
</details>

<details>
  <summary>
    <Icon icon="openmoji:cross-mark" width="20" height="20" />
    <span>DON'T: Turn on cache-style settings</span>
  </summary>
  <ul>
    <li><strong>What</strong>: Avoid settings that create unpredictability like <code>{'incremental'}</code>, <code>{'composite'}</code>, and <code>{'assumeChangesOnlyAffectDirectDependencies'}</code> in app <code>{'tsconfig.json'}</code> files.</li>
    <li><strong>Why</strong>: These introduce cache drift across environments. Prefer deterministic builds.</li>
  </ul>
</details>

<details>
  <summary>
    <Icon icon="openmoji:cross-mark" width="20" height="20" />
    <span>DON'T: Force <code>{'typeRoots'}</code> unless required</span>
  </summary>
  <ul>
    <li><strong>What</strong>: Do not set <code>{'typeRoots'}</code> without a strong reason.</li>
    <li><strong>Why</strong>: It limits which <code>{'@types'}</code> packages are visible. Defaults usually work best.</li>
  </ul>
</details>

## Troubleshooting

Find issues by using the command below to print the effective config:

```bash
tsc --showConfig --project ./path/to/tsconfig.json
```
